<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">describe(&quot;Ext.Number&quot;, function(){
    var Number = Ext.Number;
    
    describe(&quot;constraining a number&quot;, function(){
        describe(&quot;integers&quot;, function(){
            describe(&quot;if the number is within the constaints&quot;, function(){
                it(&quot;should leave the number alone if it is equal to the min and the max&quot;, function(){
                    expect(Number.constrain(1, 1, 1)).toEqual(1);
                });
                
                it(&quot;should leave the number alone if it is equal to the min&quot;, function(){
                    expect(Number.constrain(1, 1, 5)).toEqual(1);
                });
                
                it(&quot;should leave the number alone if it is equal to the max&quot;, function(){
                    expect(Number.constrain(5, 1, 5)).toEqual(5);
                });
                
                it(&quot;should leave the number alone if it is within the min and the max&quot;, function(){
                    expect(Number.constrain(3, 1, 5)).toEqual(3);
                });
                
                it(&quot;should leave a negative number alone if it is within the min and the max&quot;, function(){
                    expect(Number.constrain(-3, -5, -1)).toEqual(-3);
                });
            });
            
            describe(&quot;if the number is not within the constraints&quot;, function(){
                it(&quot;should make the number equal to the min value&quot;, function(){
                    expect(Number.constrain(1, 3, 5)).toEqual(3);
                });
                
                it(&quot;should make the number equal to the max value&quot;, function(){
                    expect(Number.constrain(100, 1, 5)).toEqual(5);
                });
                
                describe(&quot;and the number is negative&quot;, function(){
                    it(&quot;should make the number equal to the min value&quot;, function(){
                        expect(Number.constrain(-10, -50, -30)).toEqual(-30);
                    });
                    
                    it(&quot;should make the number equal to the max value&quot;, function(){
                        expect(Number.constrain(-100, -50, -30)).toEqual(-50);
                    });
                });
            });

            describe(&quot;constrain NaN&quot;, function() {
                it(&quot;should never constrain a NaN between two numbers&quot;, function(){
                    expect(isNaN(Number.constrain(NaN, 3, 5))).toEqual(true);
                });                
                it(&quot;should never constrain a NaN between zero and undefined&quot;, function(){
                    expect(isNaN(Number.constrain(NaN, 0, undefined))).toEqual(true);
                });                
                it(&quot;should never constrain a NaN between undefined and zero&quot;, function(){
                    expect(isNaN(Number.constrain(NaN, undefined, 0))).toEqual(true);
                });                
                it(&quot;should never constrain a NaN between a number and undefined&quot;, function(){
                    expect(isNaN(Number.constrain(NaN, 10, undefined))).toEqual(true);
                });                
                it(&quot;should never constrain a NaN between undefined and a number&quot;, function(){
                    expect(isNaN(Number.constrain(NaN, undefined, 10))).toEqual(true);
                });                
                it(&quot;should never constrain a NaN between two undefined values&quot;, function(){
                    expect(isNaN(Number.constrain(NaN, undefined, undefined))).toEqual(true);
                });                
            });

            describe(&quot;constrain with NaN/undefined max&quot;, function() {
                it(&quot;should ignore NaN max&quot;, function(){
                    expect(Number.constrain(2, 1, NaN)).toEqual(2);
                });                
                it(&quot;should ignore NaN max and limit to min&quot;, function(){
                    expect(Number.constrain(2, 5, NaN)).toEqual(5);
                });                
                it(&quot;should ignore undefined max&quot;, function(){
                    expect(Number.constrain(2, 1, undefined)).toEqual(2);
                });                
                it(&quot;should ignore undefined max and limit to min&quot;, function(){
                    expect(Number.constrain(2, 5, undefined)).toEqual(5);
                });                
            });

            describe(&quot;constrain with NaN/undefined min&quot;, function() {
                it(&quot;should ignore NaN min&quot;, function(){
                    expect(Number.constrain(2, NaN, 5)).toEqual(2);
                });                
                it(&quot;should ignore NaN min and limit to max&quot;, function(){
                    expect(Number.constrain(20, NaN, 5)).toEqual(5);
                });                
                it(&quot;should ignore undefined min&quot;, function(){
                    expect(Number.constrain(2, undefined, 5)).toEqual(2);
                });                
                it(&quot;should ignore undefined min and limit to max&quot;, function(){
                    expect(Number.constrain(20, undefined, 5)).toEqual(5);
                });                
            });

            describe(&quot;constrain with NaN/undefined min/max&quot;, function() {
                it(&quot;should ignore NaN min/max&quot;, function(){
                    expect(Number.constrain(2, NaN, NaN)).toEqual(2);
                });                
                it(&quot;should ignore undefined min/max&quot;, function(){
                    expect(Number.constrain(2, undefined, undefined)).toEqual(2);
                });                
                it(&quot;should ignore NaN min and undefined max&quot;, function(){
                    expect(Number.constrain(2, NaN, undefined)).toEqual(2);
                });                
                it(&quot;should ignore undefined min and NaN max&quot;, function(){
                    expect(Number.constrain(2, undefined, NaN)).toEqual(2);
                });                
            });
        });
        
        describe(&quot;floating point numbers&quot;, function(){
            describe(&quot;if the number is within the constaints&quot;, function(){
                it(&quot;should leave the number alone&quot;, function(){
                    expect(Number.constrain(3.3, 3.1, 3.5)).toEqual(3.3);
                });
                
                it(&quot;should leave a negative number alone&quot;, function(){
                    expect(Number.constrain(-3.3, -3.5, -3.1)).toEqual(-3.3);
                });
            });
            
            describe(&quot;and the number is negative&quot;, function(){
                it(&quot;should make the number equal to the min value&quot;, function(){
                    expect(Number.constrain(-3.3, -3.1, -3)).toEqual(-3.1);
                });
                
                it(&quot;should make the number equal to the max value&quot;, function(){
                    expect(Number.constrain(-2.1, -3.1, -3)).toEqual(-3);
                });
            });
        });
    });
    
    describe(&quot;toFixed&quot;, function(){
        
        var f = Number.toFixed;
        
        it(&quot;should return a string&quot;, function(){
            expect(typeof f(1)).toEqual('string');
        });
        
        it(&quot;should default precision to 0&quot;, function(){
            expect(f(1.23456)).toEqual('1');
        });
        
        it(&quot;should output the correct number of decimal places&quot;, function(){
            expect(f(1, 3)).toEqual('1.000');
        });
        
        it(&quot;should round correctly&quot;, function(){
            expect(f(1.9834657, 1)).toEqual('2.0');
        });
        
        it(&quot;should round with negative numbers&quot;, function(){
            expect(f(-3.4265, 2)).toEqual('-3.43');
        });
    });

    describe(&quot;snap&quot;, function(){

        // Params are (value, snapincrement, minValue, maxValue)
        var snap = Number.snap;

        it(&quot;should enforce minValue if increment is zero&quot;, function(){
            expect(snap(40, 0, 50, 100)).toEqual(50);
        });

        it(&quot;should enforce maxValue if increment is zero&quot;, function(){
            expect(snap(5000, 0, 0, 100)).toEqual(100);
        });

        it(&quot;should enforce minValue if passed&quot;, function(){
            expect(snap(0, 2, 1, 100)).toEqual(1);
        });

        it(&quot;should not enforce a minimum if no minValue passed&quot;, function(){
            expect(snap(21, 2, undefined, 100)).toEqual(22);
        });

        it(&quot;should enforce maxValue if passed&quot;, function(){
            expect(snap(1000, 2, undefined, 100)).toEqual(100);
        });

        it(&quot;should not enforce a maximum if no maxValue passed&quot;, function(){
            expect(snap(21, 2, undefined, undefined)).toEqual(22);
        });

        it(&quot;should snap to a snap point based upon zero&quot;, function(){
            expect(snap(56, 2, 55, 65)).toEqual(56);
            expect(snap(100, 2, 55, 66)).toEqual(66);
        });

        it(&quot;should enforce the minValue&quot;, function(){
            expect(snap(20, 2, 55, 65)).toEqual(55);
        });

        it(&quot;should round to the nearest snap point&quot;, function(){
            expect(snap(4, 5, 0, 100)).toEqual(5);
        });
        
        it(&quot;should snap negative numbers&quot;, function() {
           expect(snap(-9, 10, -100, 0)).toBe(-10);
           expect(snap(-1, 10, -100, 0)).toBe(0);
        });

    });

    describe(&quot;snapInRange&quot;, function(){

        // Params are (value, snapincrement, minValue, maxValue)
        var snapInRange = Number.snapInRange;

        it(&quot;should enforce minValue if increment is zero&quot;, function(){
            expect(snapInRange(50, 0, 0, 100)).toEqual(50);
        });

        it(&quot;should enforce maxValue if increment is zero&quot;, function(){
            expect(snapInRange(5000, 0, 0, 100)).toEqual(100);
        });

        it(&quot;should enforce minValue if passed&quot;, function(){
            expect(snapInRange(0, 2, 1, 100)).toEqual(1);
        });

        it(&quot;should not enforce a minimum if no minValue passed&quot;, function(){
            expect(snapInRange(21, 2, undefined, 100)).toEqual(22);
        });

        it(&quot;should enforce maxValue if passed&quot;, function(){
            expect(snapInRange(1000, 2, undefined, 100)).toEqual(100);
        });

        it(&quot;should not enforce a maximum if no maxValue passed&quot;, function(){
            expect(snapInRange(21, 2, undefined, undefined)).toEqual(22);
        });

        // Valid values are 55, 57, 59, 61, 63, 65
        it(&quot;should snap to a snap point based upon the minValue&quot;, function(){
            expect(snapInRange(56, 2, 55, 65)).toEqual(57);
        });

        it(&quot;should enforce the minValue&quot;, function(){
            expect(snapInRange(20, 2, 55, 65)).toEqual(55);
        });

        // Valid values are still 55, 57, 59, 61, 63, 65
        it(&quot;should snap to a snap point based upon the minValue even if maxValue is not on a snap point&quot;, function(){
            expect(snapInRange(100, 2, 55, 66)).toEqual(67);
        });

        it(&quot;should round to the nearest snap point&quot;, function() {
            expect(snapInRange(4, 5, 0, 100)).toEqual(5);

            expect(snapInRange(10, 10, 1, 101)).toBe(11);
            expect(snapInRange(11, 10, 1, 101)).toBe(11);
            expect(snapInRange(12, 10, 1, 101)).toBe(11);
            expect(snapInRange(20, 10, 1, 101)).toBe(21);
            expect(snapInRange(21, 10, 1, 101)).toBe(21);
            expect(snapInRange(22, 10, 1, 101)).toBe(21);
        });
        
        it(&quot;should handle negative ranges&quot;, function() {
            expect(snapInRange(-10, 10, -101, -1)).toBe(-11);
            expect(snapInRange(-11, 10, -101, -1)).toBe(-11);
            expect(snapInRange(-12, 10, -101, -1)).toBe(-11);
            expect(snapInRange(-20, 10, -101, -1)).toBe(-21);
            expect(snapInRange(-21, 10, -101, -1)).toBe(-21);
            expect(snapInRange(-22, 10, -101, -1)).toBe(-21);
        });
    });
    
    describe(&quot;from&quot;, function() {
        var from = Ext.Number.from;
       
        it(&quot;should handle numbers&quot;, function() {
            expect(from(2, 1)).toBe(2);
            expect(from(-2, 1)).toBe(-2);
            expect(from(999999, 1)).toBe(999999);
            expect(from(-999999, 1)).toBe(-999999);
            expect(from(999999.999, 1)).toBe(999999.999);
            expect(from(-999999.999, 1)).toBe(-999999.999);
        });
           
        it(&quot;should handle strings that represent numbers&quot;, function() {
            expect(from(&quot;2&quot;, 1)).toBe(2);
            expect(from(&quot;-2&quot;, 1)).toBe(-2);
            expect(from(&quot;999999&quot;, 1)).toBe(999999);
            expect(from(&quot;-999999&quot;, 1)).toBe(-999999);
            expect(from(&quot;999999.999&quot;, 1)).toBe(999999.999);
            expect(from(&quot;-999999.999&quot;, 1)).toBe(-999999.999);
        });
           
        it(&quot;should handle infinity&quot;, function() {
            expect(from(1/0, 1)).toBe(window.Number.POSITIVE_INFINITY);
            expect(from(-1/0, 1)).toBe(window.Number.NEGATIVE_INFINITY);
        });
           
        it(&quot;should return default value if value is not a number or numeric string&quot;, function() {
            expect(from(&quot;&quot;, 100)).toBe(100); 
            expect(from(true, 100)).toBe(100); 
            expect(from(false, 100)).toBe(100); 
            expect(from(&quot;I would like to be a number&quot;, 100)).toBe(100); 
            expect(from(&quot;12345ImAlmostANumber&quot;, 100)).toBe(100); 
        });
    });
    
    describe(&quot;randomInt&quot;, function() {
        var randomInt = Ext.Number.randomInt;
        it(&quot;should return a random integer within the specified range&quot;, function() {
            expect(randomInt(0, 100)).not.toBeLessThan(0);
            expect(randomInt(0, 100)).not.toBeGreaterThan(100);
            expect(randomInt(-100, 0)).not.toBeLessThan(-100);
            expect(randomInt(-100, 0)).not.toBeGreaterThan(0);
            expect(randomInt(1, 1)).toBe(1);
            expect(randomInt(1, 1)).toBe(1);
        });
    });

});
</pre>
</body>
</html>
